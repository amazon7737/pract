## geo hot >> what is programming? twitch streaming ( Date of stream 31 Jul 2020)

프로그래밍 이란 무엇일까? (What is Programming ?)

일단 프로그램에 정의는 뭘까? (What is the definition of a program)

Program :
  Input -> Computation -> Output
  Program takes in some input does some computation and produces some output
  
  there's an argument to be made that we should be teaching kids how to program using functional languages because
  functional languages more closely match this paradigm.
  but computers don't operate like functions computers operate a lot more like turing machines which we can get into too so maybe on one side of an extreme we have like
  a high-level functional programming language like haskell and then let's not really go lower than c and assembly are..
  c and assembly are the same structurally so you can treat c and assembly like the same ting see this kind of assembly with a
  bit of syntactic sugar around it there's nothing in c that doesn't very clearly map to something in assembly
  
  let's say like languages span the gamut from c over to Haskell right
  
  Languages:
    C --> Haskell (functional spectrum)
    
    then you can take languages and langeuages go in a few directions you can think of this a like the functional spectrum
    and then maybe there's c over to python and this is kind of the ease of use spectrum.
    
    C --> Python (ease of use spectrum)
    
    so in the 90s it was believed that object oriented programming was going to be this revolution in Programming that's
    C going to C plus plus right
    
    C --> C++
    
    basically and you can take it even further microsoft created these things called com objects and everything was
    going to be an object to pass around small talk has this kind of paradigm also but it turned out this didn't actually
    improve programmer productivity the thin that improved prgrammer productivity was garbage collection
    
    GC
    
    So when you think of a computer first I mean we kind of have to ask the question
    
    What is a computer:
    Processor (Stream of instructions)
    RAM(Instructions + Data)
    
    int main(){
      printf("hello world\n");
    }
    
    So you can think about it like you have processor that runs a stream of instructions
    and then you have ram now you can break ram into two thing there's two things stored in ram there's
    instructions and there's data so most computers really don't treat these things very differently when
    I make a program like hello world and I compile this we can take a look in this program. and that's
    not even all of it.
    
    Program:
    text = Instructions
    bss = Static Data
    stack = Local vars ( control flow)
    heap = malloc
    
    So we have a this section here this is actually the ascii for hello world so It's in the same memory
    space as the instructions itself which does the printing of hello world here's the main fuction
    It's called a dialed stub binder is actually what calls the printf so what is computer processor and
    ram then you can break down your program has text It's called dot text which is the instructions. a
    program has a stack program has a heap and a program has bss. so bss are thing like static data stack
    and there's a heap. heaps you get to through malik stacks you get to through you know anything like
    
    this is a variable on the stack
    
    void a(){
        int variable_on_the_stack;
        //return by popping off the stack
    }
    
    void b(){
    }
    
    int main(){
      a(); // pushes the return location to the stack << what this does
      b();
    }
    
    If I have a main fuction and I call a.
    So you know when I call b down here this at the end here is returned.
    Okay so this is a basic idea of what a computer is now there's a whole other direction you can
    go with the idea of what is programming right?
    there's a practical like I want to get a job right
    
    Programming for work!
    
    What does a software engineer do?
    - Don't write algorithms
    Translators:
    "Business Requirements" -> "Code"
    
    very few people actually work on(write algorithm)..
    there's some people who work on infrastructure but that's not a lot of people most software engineers are
    basically translators right
    they translate a language maybe we'll call the language business requirements into code and there's whole 
    lot of frameworks which exist to make writing things that meet business requirements easier if you think
    of a business requrement like you know we need a web page that's goning allow users to say leave a phone number
    where we can call them back right
    there's a lot of frameworks that are designed to do things like that if you wanted to write something on
    that you could use someting like ruby on rails right web apps. there's also this prardigm of crud apps
    and you get what crud stands for...
    the four basic types of sql comaand
    CRUD apps >> Create, Read, Update, Delete
    So let's say we want to buld ruby on rails or similar
    
    Frontend(View)
    
    Database(Model)
    
    Business Logic(Controller)
    
    I want to buld a portal where my customers can add their phone number such that we'll be able to call them
    they have to be able to update their phone number due to gdpr they have to be able to delete their profile
    you can see how it translates to ghis right so this is terrible you're not
    just same way the word doctor means so many things a doctor is someone who diagnoses a doctor someone who prescribes
    a doctor or someone who has bedside manner a sofeware engineer like It's kind of misleaing and this almost nothing
    like what you do in school. If you're in school and you're learning.
    how to write binary search algorithms It's nothing like what you do in practice what you do in practice is
    really you're translating from a really shitty language into these things that are like code and I meet these people
    and this is what you're going to learn
    
    What you will learn in bootcamps
    
    No one Who's ever gone to a bootcamp would ever give get a job at comma ai because at comma you don't do
    this.
    nothing at comma looks like this stupig paradigm and this is the thing that's going to be replaced pretty
    soon by ai. I thing about writing this like if you want to write the low brow version of backspace.
    backspace is basically this I mean so here step one
    
    1. Build a CRUD app contacting firm
    2. Record all the inputs of my developers(translators)
    3. Train AI model to translate "Business Logic" -> "Code"
    
    So yeah if you guys are thinking about a job like this you know it's really trash work...
    you can paid some amount of money doing it but your monks used to do this monks used to like spend time copying
    they'd have to before they were printing presses they's have to well someone's got to copy the bible that's
    practically what you're doing it's not very you know it's kind-of trash right.
    notice how none of this has anything to do with this they're completely separate things
    
    a sofeware engineer a lot of these people who I meet know basically nothing about computers
    
    what they know about is how to translate this shitty language into code is almost giving it too much
    credit and then here so let's think of like Ruby, React
    
    think of all the very heavy freameworks
    it almost has nothing to do with programming and it's like you're memorizing weird syntax of someting stupid right
    so let's talk about things that are that are more interesting all right so I learned this stuff from my
    kind of hacking background..
    
    What is hacking?
    
    Input -> System -> Output
    
    What input to the system achives my desired outcome?
    
    Pure model:
    Domain -> Funcion -> Range
    y=f(x) // 대부분의 계산은 불확실성이 있다. 무언가를 완전히 이해할 수 있는 범위 내에서 출력해야 한다.
    
   Figuring out how to make the fuction behave how you want.
   
  
   
   High Brow Sofeware Engineering
  ---
  1.Understand a complex system
  2.Modify the system to add a feature >. 기능을 추가하도록 시스템을 수정한다.
  3.Ship the new system (test well and stuff) > 테스트 웰과 같은 의미의 새로운 시스템을 제공합니다.
 
  Machine Learning Engineer
  ----
  1. Download a paper >> 알고리즘 논문을 다운받아서
  2. Implement it >> 그것을 코드(모델)로 구현해 낸다.
  3. Keep doing this until you have skills >> 이 기술을 가질때까지 이걸 계속하라.
  
  How to get a girlfriend
  ----
  
  Define: "get a girlfriend"
  
  Input -> System -> Output
  
  Women -> "female mind" -> iMessage saying "so we're official now right?"
  
  1.  100: Messages sent to women
  30%
  2. 30: Replies
  1/6 = 18%
  3. 5: Dates
  40%
  4. 2: Lays
  50%
  5. 1: Girlfriend
  
  Funnels
  ----
  
  Sell cars
  
  1. 10,000: Top of the funnel (advertising to many)
  1%
  2. 100: Visit the dealership
  5%
  3. 5: Buy cars
  
  Getting money
  ----
  
  Capitalism is based around consent.
  
  Buyer
  Seller
  
  Both parties must consent to the transaction.
  
  Getting money in a capitalist system:
    Convince others to give it to you.
    
  How do you make $1,000,000 from a product?
  
  $1 from 1,000,000 people
  - Online only
  $1,000 from 1,000 people
  - A couple phone calls can be spent closing the deal
  
  $1,000,000 from 1 person
  - Tons can be spent closing the deal
  
  How to have 1M subs on insta
  ----
  
  Instagram is based around consent.
  
  Follower
  Influencer
  
  Convince 1,000,000 people to subscribe to you
  
  1. Appealing content
    "Novelty"
    "Beauty"
    "Sexuality"
    "Funny"
    
  2. Be famous
    FOMO <-- fear (of missing something positive)
    "car crash" <-- fear (of missing something negative)
    
  3. Dark arts
    Buy followers
      Cracked accounts
      New accounts
    Make your insta private
      What's behind the curtain?
      (follow to find out)
      
   Wasting time:
   ----
   
   Existentialism -- You make your own meaning.
   
   Don't fall in funnels.
   Don't be in skinner boxes.
   Don't be influenced by advertising.
   
   output = f(x, y)
   
   f(x, y):
    f(x-1, y-1)
   
   bubble sort: O(n^2)
   for i in 0..n:
    for j in i+1..n:
      if j < i:
        swap arr[i] and arr[j]
   tree:
   n inserts into a log(n) sized tree
   7 3 4 6 10 5
   
   height: log(n)
   --       7
   --  3       10
   --    4
   --   5   6
   
   O(n * log(n))
   
   O(n) sort:
   1 and 100
   
   int cnt[100] = {0}:
   for i in 0..n:
    cnt[arr[i]] += 1
   for i in 0..sizeof(cnt):
    print("i" * cnt[i])
   
   binary search:
   find an element in a sorted list
   
   1 7 9 22 45 67 98
   
   bsearch(arr, 67):
    lo = 0
    hi = len(arr)
    
    mid = (lo+hi)/2
    
    arr[mid] is 45
    lo = mid
    
    45 67 98
    
    mid = 67
    
    Are you learning something from nature?
    Good
    
    Are you learning something from people?
    Bad
    
    Data science:
    -- stats <-- sure
    -- tooling used at company x <-- no
    -- tooling that will go out of vogue <-- no
    
    College
    ---
    
    Reject power over people
    - Ignored by the system
    - System cares deeply about power over people
    
    Embrace power over nature.
    
    Power over people used to be everthing.
    Hunter gatherer tribe
    
    Power over people is waning
    Power over nature is waxing
    
    Build a knowledge tree
    ---
    
    -- New information fits into the tree
    -- "interplation" is possible
    -- Framework for understanding
    
    Elon roots knowledge tree in Physics (modernist)
    I root knowledge tree in Information (postmodernist)
    Deserves google
    
    How to explain anything?
    
    Bezos
    ---
    
    Operations mastermind:
    
    Amazon ships many packages
    "Amazon shipping plan" is "sales pitch" to UPS
    UPS gives real rate
    Bezos wins
    
    backspace
    ---
    
    Are modern programming languages already the best way to describe what you want?
    
    How much can "automated programming" help?
    
    Does there exist a more concise programming language?
    aka what is the next GC?
    
    Compilers should do more search.

     char *a() {
        char *ret = (char *)malloc(6);
        strcpy(ret, "hello");
        return ret;  
    }

    int main() {
      int i=0;
      while (1){
        char *c = a();
        if (i%10000 == 0) printf("%s\n", c);
        free(c);
        i++;
     // fix the bug ( burn out of memory)
     
     // Pascals mugging..
     
     how does one be motivated.. this is dumb questions
     because this one weird trick to stay motivated is what you're looking for that's the only answer
     --think your own idea--
     
     

