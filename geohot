  Program:

Input -> Computation -> Output

Language:
C --> Haskell (functional spectrum)
C --> Python (ease of use spectrum)

C --> C++

GC

What is a computer:
Processor (stream of instructions)
RAM(Instructions + Data)

example : hello world programming >> 그러니까 터미널을 이용해서 hello world를 출력하는 프로그램을 C로 구현하고 그걸 데이터 베이스에서 어떻게 이루어 지는지 확인 하면서 설명한다. 
명령 자체와 같은 메모리 공간이 있다. 

int main() {
  printf("hello world"\n);
}

Program:
.text = Instructions
stack = local vars (control flow)
bss = Static Data
heap = malloc

void a() {
  int variable_on_the_stack;
  // return by popping off the stack
  }
 void b(){
 }

int main() {
  a(); // pushes the return location to the stack
  b();
}

Programming for work!

Whta does a sofeware engineer do?
>> 직접 알고리즘을 작성하는 것은 아니다
- Don't write algorithms

기본적으로 이들은 번역가이다.
Translators:
"Business Requirements" -> "Code"

example: Ruby on Rails = "Web apps"
CRUD apps <-- Create, Read, Update, Delete

Forntend (View)
Business Logic(Controller)
Database (Model)

What you will learn in bootcamp
for example : 부트 캠프에 간 사람은 comma ai 에서 일자리를 얻지 못합니다.
이런 작업을 수행하지 않기 때문이다.

이 멍청한 패러다임은 곧 ai로 대체될것 같다.
백 스페이스의 로우 브로우 버전을 작성하고 싶다면

1. Build a CRUD app contracting firm
2. Record all the inputs of my developers
3. Train AI model to translate "Business Logic" -> "Code"

이건 정말 쓰레기다 약간의 돈을 받을 수는 있다. 그냥 복사 기계같은 느낌이다.

기본적으로 컴퓨터에 대해 아무것도 모르고 
Ruby
React
(heavy framework) 그냥 이상한 구문을 외워서 하는 거다.
좀 더 재밋는걸로 가자.

what is hacking?

Input -> System -> Output

What input to the system achieves my desired outcome?

해킹이 많이 발생하는 이유는 시스템을 확인하지 않는것
내가 보내는 것이 무엇이고 시스템이 작동하는 것을 이해해야한다.

Domain -> Fuction -> Range
y= f(x)
>> 순수한 모델이다.
대부분의 계산은 불확실성이 있다. 무언가를 완전히 이해할 수 있는 범위 내에서 출력해야한다.

Figuring out how to make the function behave how you want.

입력 시스템 출력이 원하는 대로 잘 되나
입력을 잘제어하는지 잘 호출할수 있는지
시스템의 경계에서 완전히 벗어난 일을 할 수 있다.
내가 말하는건 입력 시스템 출력의 패러다임이다.

프로그래밍을 잘하는 방법이 무엇인가? 많이 물어봅니다. 하지만 나는 뭘 원해서 물어보는것인지 잘 모르겟다.
모든 웹 사이트에서 부트 캠프가 작동하는 crud 앱을 알려줍니다.

이 기본 아이디어를 연습해라 >> 해킹을 잘하기 위해서는

경쟁 프로그래밍은 어떤것에 관한것이 아니다. 
새로운 알고리즘을 만들수 있다.
패턴인식을 알게된다. >>이것은 실제로 그래프 동형 문제이다.

cdfs는 여전히 재밌다.
지능테스트라고 하기에는 너무 반복적인 속임수다.
일주일에 40시간은 연습하면 충분히 가능하다.

해킹과 코딩은 모두 새로운 기술을 배우고 적용하는 것입니다.

반복은 괜찮은 것에 반한다.

내가 이틀전에 한 방송에서의 clang에 for 루프를 추가한 곳
이정도만 해도 많은 돈을 받을 수 있다.

High Brow Sofeware Engineering
--- 이라는것
1.Understand a complex system
2.Modify the system to add a feature >. 기능을 추가하도록 시스템을 수정한다.
3.Ship the new system (test well and stuff) > 테스트 웰과 같은 의미의 새로운 시스템을 제공합니다.

>> 소프트웨어 엔지니어링과 같은 많은 계약이 있다.

clang for loop 챌린지 처럼 ( 내가보여준) 스스로에게 도전해봐라.

ML 엔지니어가 되고싶다.
Machine Learning Engineer
----
1. Download a paper 
2. Implement it >> 그것을 구현해서
3. Keep doing this until you have skills >> 이 기술을 가질때까지 이걸 계속하라.

all exmaple:
How to get a girlfriend
----

Define "get a girlfriend"

Input -> System -> Output

Women -> "female mind" ->
  iMessage saying "so we're officiall now right?"
 
1. 100: Messages sent to woemen
30%
2. 30:Replies
1/6 = 18%
3. 5:Dates
40%
4. 2:Lays
50%
5. 1:Girlfriend
  
Funnels ( 깔때기)
----
고전적인 판매이다.

Sell Cars

1. 10,000 Top of the funnel (advertising to many)
1%
2. 100: Visit the dealership
5%
3. 5: Buy cars

>> vim 레슨은 아니다.

Getting money
----

Capitalism (자본주의 ) is based around consent.

Buyer
Seller

Both parties must consent to the transaction. 

Getting money in a capitalist system: // 자본주의 체제에서 돈을 벌어
  Convince oothers to give it to you. // 당신에게 돈을 주도록 설득하느 것이다.
  
How do you make $1,000,000 from a product?
----

$1 from 1,000,000 people
- Online only
%1,000 from 1,000 people
- A couple phone calls can be spend closing the deal

%1,000,000 from 1 person
 -Tons can be spent closing the deal 

now make it look fancy put a lambo on the background and post to instagram is the new warrent buffett
>> I mean but like this stuff is so simpele

기본적으로 알아햐 한다. 여기 오래 앉아서 입력할수있다.
컴퓨터가 작동하는 방식이다. 이게 -- 이러한 컴퓨터 같은 사고방식으로 프로그래밍을 해야된다는 말인가?

Instagram is based around consent.

Follower

Infllluencer >> 이런 구조가 기본적인 경제학의 구조다.

Convince 1,000,000 people to subscribe to you

1. Appealing content ( 콘텐츠로 어필한다.)
  "Novelty"
  "Beauty"
  "Sexuallity"
  "Funny"
  
2. Be famous ( 어제 내 일을 기억한다면 좋은 방법이다.
  FOMO <-- fear (실종에 유명한 사람) (of missing something positive)
  
  "car crash" <-- fear of missing something negative)
  
3. Dark arts
  Buy followers
    Cracked accounts
    New accounts
  Make your insta private
    What's behind the curtain?
      (follow to find out)

동적 프로그래미이에 대해서 설명해 달라
다이나믹 프로그램을 위한 그래픽을 만지는 사람들
기본적인 아이디어는 당신이 어떤 기능을 가지고 있다고 말하는 것이다.

output = f(x, y)

f(x, y):
  f(x-1, y-1)

Wasting time:
----

Existentialism -- you make your own meaining

실존주의

자기 철학은 시간낭비 같은 것은 없다는 것이다.
멍청한 것처럼 시간 낭비를 하는 것은 대단하다.

Don't fall in funnels. >> 다른 사람들의 깔대기에 빠지지 마라.
Don't be in skinner boxes. >> 스키너 상자 안에 잇지 말고 영향을 받지 마세요.
Don'tbe influenced by advertising. >> ''

알고리즘 복잡성을 설명할 수 있습니까?
What is a algorithm complexity

그래프 >> 생각하는 방식

정렬은 일반적으로 복잡성에 대해 생각하는 좋은 방법이다.

버블 정렬에 대해서 알아보자.

bubble sort: O(n^2)
for i in 1..n:
  for j in+1..n:
    if j < i:
      swap arr[i] and arr[j]
>> 따라서 다른 정렬 알고리즘을 기본적으로 가지고 있는 다른 정렬 알고리즘을 사용할 수 있습니다.
만약에 내가 아는 목록을 정렬 하고 싶다.
>> 이 루프는 n 루프인데 n 제곱 정렬 알고리즘이다.
tree:

n inserts into a log(n) sized tree // n 삽입 로그인 크기의 트리이므로 실제로 정렬 알고리즘이 있습니다.

7 3 4 6 10 5

height: log(n)
--   7
-- 3    10
--    4
--  5  6

0(n * log(n)) >> n log n 시간에 있는 알고리즘은 기본적으로 이것의 변형이 있습니다.

O(n) sort: // 해시 정렬인지 이름이 뭔지 모르겠어요
1 and 100

int cnt[100];
for i in 0..n:
  cnt[arr[i]] += 1
for i in 0..sizeof(cnt):
  print("i" * cnt[i]) // n으로 가는 하나의 루프가 있고 다음으로가는 하나의 루프가 있습니다.
  
배열의 가장 큰 요소가 배열의 길이와 함께 정렬은 n의 o가 아니라 가정합니다.
100이 항상 n이지만 보통은 가장 작은 종류는 

우리는 도약 코드를 해결하지 않는다.

이진 검색 시간 복잡성을 설명 할 수 있습니까?

binary search: // 이진검색 
find an element in a sorted list

n=7 // 여기서 n 은 7보다 훨씬 작습니다.

O(log(n)) // 이진 검색이 로그 n 시간의 O를 실행하도록 배열

// 해킹을 많이 하는 것
오라클이 있다고 합시다.
67을 찾고 싶다고 해보자
1 7 9 22 45 67 98
검색 67
bsearch(arr, 67): // b 
  lo = 0 //low
  hi = len(arr) // high

  
  arr[mid] is 2 
  lo = mid
  
  
  // 그러면 일단 그걸로 간추려 지는데 배열에 mid가 22라고 가정해 보면 
  일단 67은 22보다 크므로 이 중 1,7,9중 어느 것도 될 수 없다고 안다.
  그러면 이제 low = mid 라고 말할 수 있다.
  그렇게 추려지면 밑에 처럼 된다.

22 45 67 98 // 이진 검색의 첫번째 실행

bsearch(arr, 67): // b 
  lo = 0 //low
  hi = len(arr) // high

  arr[mid] is 45 
  lo = mid
 
 // 다시 가정해보면 mid는 45이고 low 와 mid 가 같다는 것을 알 수있다.

다시 실행

45 67 98 

mid = 67 // 이번엔 미드가 67 이다. 

나무 정렬 처럼 비슷하게 생각할 수 있습니다. 
대신 하나의 경로가 정렬 된 대신 연속적으로 나열되는 목록은 얼마나 많은 점프를 할 것인지
로그인 트리를 가져와야 합니다.

초급 ML 엔지니어가 잘 구현할 수 있는 종이는 무엇입니까?

초보 ML 엔지니어를 구현할 수 있는 문서
>> 잘 모르겠다. 데이터 과학은 대부분 bs이다.
당신이 배우고 있다면 당신을 가르치는 사람 객체 수준의 기술처럼 옳은 것을 배우지 못할 것이다.
도구가 사라지면 객체 수준 기수리이 사라진다.
하지만 메타 수준의 기술을 배우고 있다면 그런 다음 그들은 결코 이건 세상에 대한
진실 같아 넌 배우고 있니?

Are you learning something from nature?
Good
Are you learning something from people?
Bad

Data Science:
-- stats < -- sure 데이터 과학이 의미한다면
-- tooling used at company x <-- no 데이터 과학이 사용된 도구와 의미가 같나?
-- tooling that will go out of vogue <--no 유행에서 벗어날 도구를 알고있다 아니..

데이터가 무엇인지 질문에 답하는 것과 같습니다.



물리학처럼 배우는 경우에 패러다임은 자연 학습에서 비롯됩니다.
유명인 가십을 배우고 있다면 물리학이 좋다.
사람들에 대한 임의의 헛소리는 나쁘다.

대학의 창립 테마중 하나를 알고 우리는 사람들에 대한 권력을 거부합니다.

College
---

Reject power over people
-Ignored by the system
-System cares deeply about power over people

--- 
자연에 대한 힘을 받아 들여라
Embrace power over nature

양의 실수 부분이 있는 복잡한 s에 대해 f를 정의합시다.

함수의 모든 0을 어떻게 찾습니까?
riemann 가설처럼 이상하게 보이는..
내 수학 지식의 대부분은 이산 수학에 있다.
잘 몰라

미적분에는 시뮬레이터를 작성할 수 있다는 것을 의미하는 방법을 정말 모른다.
그런 다음 함수가 연속적이라고 가정하고 0을 이진 검색 할 수 있습니다.

우리는 정확히 이진 검색을 할 수 없습니다.

잘 모르겟다.

배고픈 상태를 유지하는 방법에 어떤 책을 추천합니까?
elon은 이것에 대해 많이 말하고 있으므로 지식 트리를 만들고 싶습니다.

Build a Knowlege tree
----

--New information fits into the tree // 내가 만난 사람들이 많은 것을 알고있는 그런 사람들이 항상
그들이 아는것도 아니고 

-- "interpolation" is possible //일부 노드가 있으면 나무의 메모가 무엇인지 정확히 알지 못하더라도
근처에서 바로 보간 할 수 있습니다. ( 두개 이상의 객체를 연결할 수 있다.
그래서 그것은 일종의 프레임 워크다.
-- Framework for understanding

Elon roots knowledge tree in Physics (modernist)
I roots knowledge tree in Information (postmodernist)

두가지 모두 좋은 방법이다.

How to explain anything?

여자 친구에게 올바른 입력 시스템 출력을 얻는 방법이 내 핵심이다.
무엇이든 이해하기위한 패러다임

Bezos // 베조가 기본적으로 이것을 사용합니다.
----

Operations mastermind:

Amazon ships many packages
"Amazon shipping plan" is "sales pitch" to UPS // 아마존은 UPS라는 것을 사용한다.
UPS gives real rate
Bezos wins // 이게 바로 아마존의 속임수다.

그것은 전체 세계이고 나는 그것을 이해하기 위해 최선을 다합니다.

나는 항상 그곳에서 관광객이 될 것 같아.

내가 어렸을 때 다르게 하고 싶었던 한 가지는
사실 나는 거의 완전히 거부하지 않았다
인문학,,, 그런 애들은 트롤들임
자라면서 깨달았을 때 대학과 특이점
과학은 중요하지 않습니다. 역사상 비극은 믿을 수 없을 만큼 똑똑한 과학자들이
핵폭탄을 발사한 다음 그 폭탄을 그들에게 복종하는 정치인에게 넘겨주엇다.
왜 이것이 왜 정치이니이나 그런 종류의 사람들은 이 힘을 가지고 있나
그래서 역사를 통틀어 변하고 있는 것 사람들에 대한 권력이다.

Power over people used to be everything.
Hunter gatherer tribe 
만약 당신이 부족에 살았다면 수렵채집이나  
당신을 알파 침팬지로 만든 것은 다른 침팬지들에 대한 힘을 가지고 있었다는 것입니다.
자연에 대한 힘이 없는 넌 10배 더 나은 사냥꾼이 아니야
10배 더 나은 사냥꾼은 없었지만 사람들을 지배하는 힘은 약해지고

Power over People is waning
Power over Nature is waxing ( waxing 겉보기 크기를 늘려서)

내가 엄청난 것이 있다는 것을 깨닫기 시작했을 때
회사를 운영하는 것이 무엇인지
ceo는 당신이 하는 모든 것을 이야기하는것이다. 그렇게 하는 것을 이야기 하는 것이고 우리는 경쟁한다.
이 이야기의 경쟁

이런 것들이 요즘 오프 스트림에서 하고 있는 많은 일중에 하나다. 특히 지금은 독서일 뿐 이고
해킹에 미래가 없어요 그리고 프로그래밍에는 미래가 거의 없습니다. 특이점이 발생한다면 언제
그리고 그것은 어떻게 보일 것이고 그것이 어떻게 보일것 같습니까?
그런트를 하는 프로그래머들에 의해 훨씬 덜 누가 최고의 이야기를 하는지에 따라
세상을 더 잘 구하고 싶다면 이야기하는 법을 배워라

프로그래밍 전문가가 되는 법을 가르쳐주세요
턴 페이퍼는 모두가 꼭 읽어야한다.
// 이 사람들은 어디에나 있기 때문에 모든 생물학자들은 모두 화학자가 되기를 원합니다.
화학자는 물리학자가 되고 싶어하는 반면 물리 학자들은 수학자 모든 수학자는 철학자와 모든 철학자가 되기를
원합니다.
고용되고 싶다.

프로그래머는 번역가에요
이것이 대부분의 소프트웨어 엔지니어가 하루 종일 하는 일입니다.
어리석은 프레임워크를 제데로 배우지만 다시 그것은 나의 데이터 과학에 대해서도 마찬가지다.
유행에서 벗어날 도구를 알고 있습니다.

그게 맞을지도 몰라 

오늘날 우리는 덜 혁신적인 혁신 정신을 가지고 있다고 생각합니까?

>> 확실히 혁명적인 사람들이 있습니다. 
내가 생각하는 가장 혁명적인 사람은 현대에 천년기 나카 모토 사토시

정말 어떤 식으로든 일을 하고 싶다면 익명으로 해야합니다.

엘론머스크가 뭘하는지 보시죠. 확실히 사람들이 있어요
100년 뒤에 기억될 오늘 살아있는 

내가 논문을 읽는 이유 >> 책 추천??

The Annotated Turing
좋은 직업윤리가 무엇인지 추천

그러니 무대에 서서 이렇게 말하는 정치인이 있다면 아이들은 우리의 미래입니다.
아이들이 정말로 말하지 않는 것을 걱정합니다.

난 당신이 아무거나 해야한다고 말하는 것이 아닙니다.

그것은 단지 프레임 워크 일 뿐입니다. 생각에

질문에 답하는데 정말 관심이 없습니다. 내 자신에

나도 그렇고 너도 아무도 아니다.

재귀에 대해 (stack)

신중한 개발은 사라질 것입니다.
현재 개발은 가장 낮은 공통 분모가 될것입니다.
글쎄요, 저는 엔지니어들로부터 물건을 가져와서 
고객과 나는 엔지니어에게 바로 제공합니다.
그게 다야

구성주의에 대한 나의 이해

당신은 법의 법칙을 제외된 중간은 적용되지 않습니다. 그래서 당신은 가정을 할 수 없습니다.
모순을 찾아서 가정이 사실이라고 말하십시오
뭔가 사실이라고 말하고 싶다면 그냥 할 수 없다고 말하면 안된다고 그래 모순을 찾아서 
finitism 처럼 나는 깊은 철학적 의미에서 진실이라고 믿는다.
구성주의는 또 다른 렌즈에 불과한거다.

비 구성주의 수학에서 무엇을 말할 수 있습니까?
당신이 구성 주의자로 말할 수 없거나 더 어려운 증명...
수학자에서 제외 된 중간의 원칙을 취하면 망원경을 처방하는 것과 같은 말 천문하기자 또는
그의 주먹 사용 상자

아 구조는 Google이 실제로 나에게 줄 것입니다
이것에 대한 무엇이든 나는 비 구성 주의적 진실을 원한다.
당신은 구성주의에서 도출 할 수 없습니다

어떤 것들은 학습 이론과 같은 것입니다.
내가 알고 싶은 것은 마치 진실이 옳은 것과 같은 것입니다.


What is money?
---
그 누구에게도 결코 최종 목표가 아니라는 것입니다.
돈을 버는 것은 최종 목표가 될 수 없습니다.
돈 자체에는 내재적 가치가 없습니다.

항상 당신의 터미널 가치가 옳은지 생각하십시오
정복되지 않은 국가를 상상하는 것은 충분히 쉽습니다.

무언가 강한 충격을 주는 무언가를 사람들에게 주어야합니다.

둘째, 누군가의 규칙을 포함해서 규칙을 따르지 않거나 반대하는 경우
모든 시민들은 그것을 죽이기 위해 단결해야 합니다.

사람들은 이러한 규칙이 전통에 의해 충분히 확립되엇다고 가정합니다.
당신이 그렇지 않으면 다른 사람들이 당신을 죽일 것이라는 것을 알기 때문에 하루 그들은 다른 모든 사람들이 그들을 죽일 수는 없습니다.

러시아인들이 탈북을 막기위해 비슷한 전술을 사용했다고 들었습니다.
제2차 세계대전 당신은 정면에 군인을 알고 기관총 포탑을 충전하라는 지시를 받은 라인은
다른 방법으로는 모든 사람의 일이라는 것을 알고 있습니다.
그들 뒤에 모든 겁쟁이를 쏘고 겁쟁이를 쏘지 않으면
겁쟁이가 되고 다른 사람에게 총을 맞을 것입니다.
독재없는 디스토피아 그러니 당신이 정말로 돈을 원하는지 생각해보세요
왜냐하면 우리는 정말로 이러한 독재자 디스토피아 중 하나에
그래서 내 시청자 수가 줄어들었고 겁쟁이는

러시아 시슽메은 우리가 혁신적인 아이디어를 가지고 있습니까?

파이가 무한에 자리에 들어갈수 있는 것을 증명할수 있는가?
이건 고전적인 것이다. 하지만 당신이 이것을 충분히 증명할 수 있습니다.

새로운 세대가 낮은 수준과 같은 것을 배우기를 기대하는 곳 < 대학>
프로그래밍이나 이론 같은 곳에서 다른 사람들이 무슨 말을 했는지
사람들은 항상 컴퓨터 과학에 대해 이렇게 말합니다.

실제로 컴퓨터가 작동하는 방식을 배우지는 않을 것입니다.
왜 우리 수학 전공자들은 산술이 어떻게 작동하는지 모르기 때문에
누군가 교육을 잘 못 받았다는 신호일뿐
사람들이 이렇게 말하는 세상에서 페이드를 좋아하지 않을 것입니다.
당신은 너무 많은 다른 분야가 있다는 것을 알고 있으며 왜 그들이
컴퓨터 과학이
다른 건지

배울게 너무 많아서 근사치를 모르겠다...

웹사이트의 진실성 
그냥 진실만을 쉽게 전달해주는 사이트인지
아니면 그렇지 않은지

대학은 이보다 훨씬 더 닮은 웹 사이트를 갖게 될 것입니다.

컴퓨터 아키텍처 또는 정량적 접근 방식을 살펴 보겟습니다
대학은 깔때기 사회의 깔때기

컴퓨터 아키텍처를 공부하고 싶다면 이것이 예다 라면서 어떠한 특정한 책의 목차를 보여줌
이건 구글에서 온건데
l1 캐시에 도달하는 데 10 나노초 정도 걸립니다.
l2에 도달하는 데 100나노초는 메모리에 도달하는 데 마이크로 초가 걸립니다.
디스크에 도달하는 데 1밀리 초 정도 걸립니다.

그 모든 메모리 계층 구조를 이해한다는 것을 아십시오.

컴퓨터 과학에 두가지 어려운 문제가 있는 것처럼
검색 및 캐싱 또는 that is quote 어떤 정보에서 인용했다

백스페이스로 인한 문제
Backspace
---

우리의 현대적인 프로그래밍 언어는 이미 원하는 것을 설명하는 가장 좋은 방법

Are modern Programming languages already the best way to describe what you want?

How much can "automated programming" help?

for example:
  프로그램이 실제로 설명하는 것이 무엇인지
  아마도 더 나은 방법인 더 간결한 언어가 있습니까?
  더 간결한 것이 있습니까?
  Does there exist a more concise programming language?
  
  aka what is the next GC?
  
  객체 지향 프로그래밍은 개선 사항을 제공하지 않았습니다. >> 이말은 더이상 나아질 방향이 없고 이미 거의 완벽한 상태다?
  
  수집은 당신의 자유를 다룰 필요가 없었습니다.
  
  메모리.. 음 내가 말하는 건 내 기본 논문은 컴파일러가 더 많은 검색을 해야한다는 것입니다.
  
  Compilers should do more search.
  
  gc is garbage collection.
  
  내가 c코드를 작성하면 함수를 만들어 보자.
  
  char *a() {
    char *ret = (char *)malloc(6);
    strcpy(ret, "hello");
    return ret;
}

int main() {
  int i=0;
  while (1){
    char *c = a();
    if (i%10000 == 0) printf("%s\n", c);
    free(c);
    i++;
  }
}
  
  닷 아웃의 메모리를 보세요
  메모리 사용량이 증가하고 있으며 유지하기 전에 죽여야합니다.
  메모리 누수가 있기 때문에 더 많이 사용
  이 프로그램에서 일어나는 일은 a가 호출 될때마다 6바이트의 메모리를 사용하고 있스빈다. 6바이트를 사용하고 있습니다.
  합에서 떨어져서 이 while 루프가 다시 돌아 오더라도 바이트는 절대 접근 할 수 없습니다. 컴파일러는 프로그램이 이미 할당 했으므로 이 문제를 해결해야합니다.
  
그래서 너는 이걸로 버그를 수정할 수 있습니다. free(c); <<
이제 메모리 사용량이 증가하지 않음을 알 수 있습니다.
gc가 자동으로 도달 할 수 없는 포인터를 찾아 해제합니다.

그래, 녹은 별개의 아이디어를 가지고 있습니다. russ는 소유권에 대한 아이디어를 가지고 있습니다.
하지만 녹을 코딩하기 매우 어렵게 만듭니다.

gc의 장점은 백그라운드에서 완전히 작동하고 실행하기에 유효한 프로그램이 됩니다.
나는 이것을 go에 쓰고 gc로 갈 수 있으며 괜찮습니다.
데이터를 출력하는 가장 짧은 프로그램을 찾을 수 있다면 

문자열 복사를 null 없이 문자 배열로 전달하면 어떻게 되나요?
계속 복사해야해
그것을 찾을때까지 스택에 무엇이든지 터미네이터

우리가 언어를 작성하기에 효율적이지 않다는 표시입니까?
근본적으로 다른 함수형 프로그래밍이있을 때
내말은 음, 나아지고 있어 난 아주, 내가 코드에 뭘 줄지 알 잖아
20년 후의 언어 너무 행복 할거야

지속적인 성장을 해결하는 방법을 알고 잘못된 정보 내말은 그 비율이 실제로 있었다.
더 나쁜 것은 정보의 비율이 잘못된 정보가 변경되었는지 잘 모르겠습니다.

어떻게 동기를 부여 받나요?
왜 그렇게 생각하지? 멍청한 질문입니다.
어떤 것이 멍청한 질문인지 아닌지가 구조가 무엇인지 생각하는 것과 같다면
당신이 원하는 대답의 어떤 종류의 구조와 같은 공간은 무엇입니까 범위는 어떻게 생겼습니까?
출력 공간은 어떻게 생겼습니까? 당신은 Google을 받을 자격이 있는 사람입니다.
의욕을 유지하기 위한 이상한 속임수 때문에 당신이 거기에서 찾고있는 것이고 그것이 당신이 갈 유일한 대답입니다. 실제 답이 아니므로
호기심에 만족하고 당신은 같은 쓰레기를 계속 인터넷 검색을 할 것입니다. 몇 번이고 몇번이고 대답이 없어
계층 및 정보 배포가 적습니다.
나는 그것에 대해 확신하진 않는다.

그러니 어떤면에서 더 많은 계층이 있다고 생각해보세요.
오 괜찮아요 제가 찾을 수 있는지 알아 볼게요 색인 할 좋은 방법이 있었으면 좋겠어요
그들이 책에 넣은 정확한 인용구를 찾아 보겠습니다.
가족은 비진리와 흔히 공유되는 거짓말에 대해 사람들이 많이 말 했음에도 불구하고 내 관점에서
어떤 방식으로든 잘못된 정보를 사람들은 가짜 뉴스에 대해 비명을 지르고 있습니다.
그들은 잘못된 정보에 대해 계속 이야기 하고 있습니다.
내러티브는 더 이상 새로운 내러티브가 오래된 내러티브보다 덜 사실 오래된 내러티브도 모두 거짓말입니다.
새로운 이야기를 제공하는 다른 종류의 그룹이 있습니다.
새로운 내러티브는 다른 곳에서 온다 옛날 이야기보다 조금 더 사실이라고 생각하지만 약간

송곳니 인터뷰를 크랙하라는 조언 솔직히 그들이 당신을 앉히고 두가지 리드 코드 어려운 문제를 
이것이 제가 여러분을 위해 스트림에서 리드 코드를 하지 않는 이유입니다. 왜 그들이 시간을 낭비하는게 아니라는것을 기억하면서
그냥 모욕하는 건 내말은 모두에게 모욕적이라고 생각한다.
누가 인터뷰를 하고 있는지 확인하지 않는 것처럼 당신이 좋은 프로그래머인지 아닌지 그들은 당신이 몇시간, 몇시간동안 갈아서
오른쪽 삭제 코드 갈기는 진짜 같은 조직의 종류입니다. 당신을 소중히 여기는 조직에서 일하고 싶어합니다.
어리 석고 무관한 것을 몇시간 동안 연마.. 음, 프로그래밍 문제는 놀라운 방법이라고 생각합니다. 
후보자를 판단하지만 시간이 맞지 않은 것 우리는 좋아 또는 적어도 사람 앞에서 시간이 부족하지 우리는 comma에 대한
해킹 도전이 있습니다. 음, 하지만 우리는 당신에게 4시간을 줍니다. 당신이 좋다면 당신은 시간 같은건 설계되지 않았습니다.
신입생 제초기 테스트를 위해 설계되었습니다. 이것이 우리가 진정으로 판단하는 방법입니다.
스피드 챌린지 그래 난 스피드 챌린지 좋아해 더 개방적이지만 더 명확한 엄격한 평가기준을 가져오는 것이 중요합니다.
편견을 피하기 위해 명확한 평가 기준이 있는 인터뷰 암페타민을 복용하지마라 각성제는 당신이 일을 더 잘하게 만들지 않는다는 것입니다.
그들은 당신이 일을 더 잘한다고 생각하게 만듭니다. 그들은 망상을 촉발하고 내가 뭔가를 잘한다면
내가 뭔가를 잘한다고 믿고 싶다. 내가 뭔가에 나쁘다고 믿고 싶어 nootropics는 대부분 사기입니다.
저는 인문학이 내부의 구조와 계층을 벗어날 수 있을 것이라고 생각합니다.
트랜스 휴머니즘과 싸우는 자연은 나는 확실하지 않다. 정확히 그게 무슨 뜻인지
정직은 깊은 생각을 주지 않습니다. 깊이 나는 더 긍정적인 말이었다. 암페타민에 대해 내가 하는 것보다 lsd가 당신에게
뭔가를 보여준 것 같아요 내 말은 당신이 아는 모든 약과 같다 무엇을 가르쳐야하는지 이해 한다음 멈춤
10일간의 명상 수련회에 가고싶어요
하지만 마약에 대해 얘기하고 싶지 않아요 그들은 마약이 아닙니다.
그 흥미로운
나 자신에 대해 이야기하는 것을 좋아합니다.
나 자신에 대해 이야기하고 내 아내를 위해 일화를 제공합니다. 요점을 설명하는 것이 더 많습니다.
왜냐하면 제가 제 자신에 대해 말하는 것은 개인적이고 쓸모 없어 나처럼 굴지 마 바보야

당신이 생각할 수 있도록 내가 당신에게 정보를 주고 화이트 노이즈.. 일부 이야기는 구성되어 있습니다.

불법 복제의 도덕성 나는 보편적인 도덕성 또는 윤리를 믿지 않습니다.
너 자신의 마음에 들어라
음, 노력하는 사람은 있지만 설교하려는 사람은 싫어합니다.
당신의 도덕성 또는 윤리는 당신이 어떻게 행동해야하는지 말해 주려고 합니다.
그저 강력한 사람들이기 때문에
도덕적 상대주의자 나는 개인적인 차용을 가지고있다.
















